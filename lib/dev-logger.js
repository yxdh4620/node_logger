// Generated by CoffeeScript 1.8.0
(function() {
  var Logger, LoggerLevel, PID, fs, util;

  fs = require("fs");

  util = require("util");

  LoggerLevel = require('./enums/logger_level');

  PID = "[" + process.pid + "]";

  Logger = (function() {
    function Logger(options) {
      var key, _i, _len, _ref;
      if (options == null) {
        options = {};
      }
      this._isDebug = options.isDebug || false;
      this._level = options.level || LoggerLevel.LOG;
      this._path = options.level;
      this._resetInterval = options.resetInterval;
      this._flushInterval = options.flushInterval;
      this.setLevel(this._level);
      this.setPath(this._path);
      this._cache = {};
      _ref = LoggerLevel.LEVELS;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        this._cache[key] = [];
      }
    }

    Logger.prototype._async = function() {
      return this._flushInterval = setInterval((function(_this) {
        return function() {
          var key, logs, value, _ref, _results;
          _ref = _this._cache;
          _results = [];
          for (key in _ref) {
            value = _ref[key];
            if (value.length === 0) {
              continue;
            }
            logs = value.join("");
            if (_this._flushLog(key, logs)) {
              _results.push(value.length = 0);
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
      })(this), 5 * 1000);
    };

    Logger.prototype.setPath = function(path) {
      if (path) {
        this._path = path;
        this._resetStream();
        if (!this._resetInterval) {
          this._resetInterval = setInterval(((function(_this) {
            return function() {
              return _this._resetStream();
            };
          })(this)), ROTATION_INTERVAL);
        }
        this._flushLog = this._flushLogToFile;
      } else {
        this._flushLog = this._flushLogToConsole;
      }
      return this;
    };

    Logger.prototype.setLevel = function(level) {
      var i, method, _i, _len, _ref;
      if (level == null) {
        level = 0;
      }
      _ref = LoggerLevel.LEVELS;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        method = _ref[i];
        if (i < level) {
          this._defineNoopMethod(method);
        } else {
          this._defineMethod(method);
        }
      }
      this._level = level;
      return this;
    };

    Logger.prototype._defineMethod = function(name) {
      var tag;
      tag = LoggerLevel.NAME_TAG[name];
      if (this._isDebug) {
        return this[name] = function() {
          return console[name](PID, (new Date).toLocaleString(), tag, util.format.apply(null, arguments));
        };
      } else {
        return this[name] = (function(_this) {
          return function() {
            _this._cache[name].push("" + PID + " " + (new Date().toLocaleString()) + " " + tag + " " + (util.format.apply(null, arguments)) + "\r\n");
          };
        })(this);
      }
    };

    Logger.prototype._defineNoopMethod = function(name) {
      return this[name] = NOOP_FN;
    };

    Logger.prototype._flushLogToFile = function(level, logs) {
      if (!(this._stream && this._stream.writable)) {
        this._flushLogToConsole(level, logs);
        return true;
      }
      this._stream.write(logs);
      return true;
    };

    Logger.prototype._flushLogToConsole = function(level, logs) {
      console[level](logs);
      return true;
    };

    Logger.prototype._resetStream = function() {
      var day, error, logPath, month, options, today, year;
      if (!this._path) {
        return;
      }
      today = new Date();
      year = "" + (today.getFullYear());
      month = "" + (today.getMonth() + 1);
      if (!month[1]) {
        month = "0" + month;
      }
      day = "" + (today.getDate());
      if (!day[1]) {
        day = "0" + day;
      }
      logPath = this._path.replace("%Y", year).replace("%m", month).replace("%d", day);
      if (logPath === this._realPath) {
        return;
      }
      this._realPath = logPath;
      options = {
        flags: 'a',
        encoding: 'utf-8',
        mode: '0644'
      };
      if (this._stream) {
        try {
          this._stream.destroySoon();
        } catch (_error) {
          error = _error;
          this.error("[logger:_resetStream] Failed to close stream. Error: " + error);
        }
      }
      try {
        this._stream = fs.createWriteStream(logPath, options);
        logger.info("[logger:_resetStream] Rotate to new log path: " + logPath);
      } catch (_error) {
        error = _error;
        this.error("[logger:_resetStream] Failed to create stream. Error: " + error);
        this._stream = null;
      }
    };

    return Logger;

  })();

  Logger.ERROR = LoggerLevel.ERROR;

  Logger.WARN = LoggerLevel.WARN;

  Logger.INFO = LoggerLevel.INFO;

  Logger.LOG = LoggerLevel.LOG;

  module.exports = Logger;

}).call(this);
